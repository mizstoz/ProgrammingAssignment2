y[y>0]
x[x>0]
x[!is.na(x) & x > 0]
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10)]
x[-c(2,10)]
vect <- c(foo=11,bar=2,norf=NA)
vect
name(vect)
names(vect)
vect2 <- c(11,2,NA)
names(vect2) <- c("foo","bar","norf")
identical(vect,vect2)
vect["bar"]
vect[c("foo","bar")]
my_vector <- 1:20
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector) <- c(4,5)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?"matrix"
?matrix
my_matrix2 <- matrix(1:20,4,5)
identical(my_matrix,my_matrix2)
patients <- c("Bill","Gina","Kelly", "Sean")
cbind(my_matrix,patients)
cbind(patients,my_matrix)
my_data <- data.frame((patients,my_matrix))
my_data <- data.frame(patients,my_matrix)
my_data
class(my_data)
cnames <- c("patient","age","weight","bp","rating","test")
colnames(my_data,cnames)
colnames(cnames,my_data)
?colnames
colnames(my_data)<- cnames
my_data
TRUE == TRUE
(FALSE == TRUE) == FALSE
6==7
6<7
10 <= 10
5 !=7
7 != 5
!5==7
FALSE & FALSE
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE | c(TRUE, FALSE, FALSE)
TRUE || c(TRUE, FALSE, FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTRUE((6>4))
isTRUE(6>4)
identical('twins','twins'')
''
identical('twins','twins')
xor(5 == 6, !FALSE)
ints <-sample(10)
ints
ints > 5
which(ints >7)
any(ints < 0)
all(ints > 0)
exit
quit
x <- "001:010"
y <- c(x)
y <- 1:10
y <- x
y <- is.numeric(x)
y <- as.numeric(x)
y <- 001:010
y <- as.vector(x)
q()
setwd("D:/Coursera/R Programming/Working Directory/ProgrammingAssignment2")
?solve
?function
.
?function
.
B = matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=2)
b <- matrix(c(1,2,3,4),nrow=2,ncol=2)
b
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
setOriginal <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
getOriginal <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(setOriginal = setOriginal, getOriginal = getOriginal, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
cached_matrix <- solve(original_matrix$getOriginal())
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
cacheSolve(b)
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
setOriginal <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
getOriginal <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(setOriginal = setOriginal, getOriginal = getOriginal, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
cached_matrix <- solve(original_matrix$getOriginal())
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
cacheSolve(b)
b
b <- data.frame()
rbind(b,c(1,2))
rbind(b,c(3,4))
b<-rbind(b,c(1,2))
b<-rbind(b,c(3,4))
b
cacheSolve(b)
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
setOriginal <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
getOriginal <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(setOriginal = setOriginal, getOriginal = getOriginal, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix = matrix(), ...) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
cached_matrix <- solve(original_matrix$getOriginal(), ...)
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
cacheSolve(b)
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
set <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
get <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(set = set, get = get, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix = matrix(), ...) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
cached_matrix <- solve(original_matrix$get(), ...)
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
cacheSolve(b)
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
set <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
get <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(set = set, get = get, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix = matrix(), ...) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
mat_content <- original_matrix$get()
cached_matrix <- solve(mat_content, ...)
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
cacheSolve(b)
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
set <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
get <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(set = set, get = get, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix = matrix(), ...) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
cached_matrix <- solve(original_matrix$get(), ...)
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
b <- makeCacheMatrix()
b$set(matrix(1:4,2,2)
)
b
b$get()
cacheSolve(b)
solve(matrix(1:4,2,2))
solve(matrix(4,7,2,6))
2c(4,7,2,6)
solve(matrix(c(4,7,2,6),2,2))
solve(matrix(c(4,2,7,6),2,2))
b$set(matrix(c(4,2,7,6),2,2))
cacheSolve(b)
## The is my solution to Programming Assignment 2.
## The pair of function here will attempt to
## reterive a previous cached inveresed matrix or
## calculate the inverse matrix if the cached is
## not available.
## This function will create a special matrix that
## all for get and set the original and inverse of
## the matrix.
makeCacheMatrix <- function(original_matrix = matrix()) {
## Set the cached matrix to null
cached_matrix <- NULL
## Function to store the original matrix
set <- function(orig_mat)
{
original_matrix <<- orig_mat;
cached_matrix <<- NULL;
}
## Function to return the original matrix
get <- function()
{
return(original_matrix);
}
## Function to store the cached matrix
setInverse <- function(inv_mat)
{
cached_matrix <<- inv_mat;
}
## Function to return the cached matrix
getInverse <- function()
{
return(cached_matrix);
}
## List of available function
return(list(set = set, get = get, setInverse = setInverse, getInverse = getInverse))
}
## This function will check for the cached of the
## inverse matrix first.  If the cached exists,
## it will return the cached value, else it will
## calculate the inverse matrix and stored it in
## the cached.
cacheSolve <- function(original_matrix = matrix()) {
## Attempt to retrieve pervious cached of the inverse matrix
cached_matrix <- original_matrix$getInverse()
## If cached is found, return it.
if(!is.null(cached_matrix))
{
return(cached_matrix)
}
## Calculate the inverse of the matrix
cached_matrix <- solve(original_matrix$get())
## store it into the cache for future use
original_matrix$setInverse(cached_matrix)
## Return the inverse of the matrix
return(cached_matrix)
}
cacheSolve(b)
b$get()
b$get()*b$getInverse(())
b$get()*b$getInverse(b)
b$get(b)*b$getInverse(b)
b$get()*b$getInverse()
b$get()%*%b$getInverse()
